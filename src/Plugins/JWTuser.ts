/**
 * @file JWTuser
 * @author Jim Bulkowski <jim.b@paperelectron.com>
 * @project jwt-session
 * @license MIT {@link http://opensource.org/licenses/MIT}
 */


import {CreatePlugin} from "@pomegranate/plugin-tools";
import {extend, get, isFunction} from 'lodash/fp'

//@ts-ignore
const mutableExtend = extend.convert({immutable: false})
const tsGenerator = `// Generated by the Pomegranate cli on {{creationDate}}

// name: {{name}}

export const populateJWTUser = (Controllers, Actions) => {
  return async (decodedJwt) => {
  
  }
}
`

export interface JWTuser {
  init: () => any
  update: () => any
  expire: (cb: any) => any
}

export const JWTuser = CreatePlugin('anything')
  .configuration({
    name: 'JWTuser',
    injectableParam: 'JWTuser',
    injectableScope: 'global',
    depends: ['@pomofficial/Redis', '@restmatic/Actions'],
    provides: ['@restmatic/RouteSecurity']
  })
  .directories([{
    prop: 'main',
    path: '.'
  }])
  .variables({
    redisPrefix: 'fake'
  })
  .hooks({
    load: async (Injector, PluginLogger, PluginFiles, PluginVariables, Redis, Actions) => {
      PluginLogger.log('Creating SessionSecurity methods', 1)
      let p = await PluginFiles('main').workingDirectory
      let required = require(p)
      let mw = get('populateJWTUser', required)

      if (!mw) {
        throw new Error(`JWTuser file does not contain an export on the populateJWTUser property.`)
      }
      if (!isFunction(mw)) {
        throw new Error(`JWTuser file does not export an injectable function on the populateJWTUser property.`)
      }

      const populateJWTUser = Injector.inject(mw)
      console.log(populateJWTUser)

      return (decodedJwt, next) => {
        let keyName = `${PluginVariables.redisPrefix}:${decodedJwt.uuid}`
        let U = {} as JWTuser
        Object.defineProperty(U, 'update', {enumerable: false, writable: true});
        Object.defineProperty(U, 'init', {enumerable: false, writable: true});
        Object.defineProperty(U, 'expire', {enumerable: false, writable: true})

        U.init = function () {
          const _this = this
          if (!decodedJwt || !decodedJwt.uuid) {
            return next()
          }

          Redis.getAsync(keyName)
            .then((value) => {
              if (value === null) {
                return ['db', populateJWTUser(decodedJwt)]
              }
              return ['redis', JSON.parse(value)];
            })
            .spread(function (source, user) {
              if (source === 'db') {
                let plainUser = user.get({plain: true});
                let jsonUser = JSON.stringify(plainUser);
                return Redis.setAsync(keyName, [jsonUser, 'EX', 60])
                  .then((result) => {
                    return plainUser
                  })
              }
              return user
            })
            .then((redisInsert) => {
              if (redisInsert) {
                mutableExtend(_this, redisInsert)
              }
              next && next()

            })
            .catch((err) => {
              PluginLogger.error('Failed to parse redis response correctly.')
              PluginLogger.error(err)
            })
        }
        U.update = () => {

        }
        U.expire = (cb) => {
          Redis.del(keyName, function (err, status) {
            cb && cb(err)
          })
        }

        U.init()
        return U
      }
    }
  })
  .commands(function (PomConfig, PluginFiles, Handlebars) {
    return (yargs) => {
      return yargs
        .usage('usage: $0')
        .command({
          command: 'generate',
          aliases: 'g',
          describe: `Generates Serializer file`,
          builder: (yargs) => {
            return yargs
              .option('l', {
                alias: 'language',
                describe: 'Generate TypeScript or Javascript',
                default: 'ts',
                choices: ['ts'],
                type: 'string'
              })
              .option('force', {
                alias: 'f',
                default: false,
                describe: 'overwrites the specified file if it exists.',
                type: 'boolean'
              })
          },
          handler: async (argv) => {
            let Pf = PluginFiles('main')
            let file = `index.${argv.language}`
            let exists = await Pf.projectFileExists(file)
            let compile = Handlebars.compile(tsGenerator)
            let compiled = compile({creationDate: new Date().toDateString(), name: 'index.ts'})

            if (exists && !argv.force) {
              throw new Error(`${file} \n exists \n Rerun with --force to overwrite.`)
            }
            await Pf.outputProjectFile(file, compiled)
            console.log(`Created @restmatic/authentication Serializers file ${file}`)
          }
        })
        .help()
    }
  })